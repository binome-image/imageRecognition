\documentclass{report}

\title{Rapport Projet Image}
\author{Patrice Coudert}
\usepackage{xcolor}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{tikz}
\usepackage[nottoc, notlof, notlot]{tocbibind}
\usepackage{amsthm}
\usepackage{stmaryrd} 
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{lmodern}
\usepackage{amsmath,amsfonts}
\newcommand{\TextSoulign}[3]{\emph{\textcolor{#1}{\underline{#2\textcolor{black}{#3}}}}}
\newtheorem{lemme}{Lemme}
\newtheorem{theoreme}{Théorème}    
\newtheorem{mydef}{Définition}
\newtheorem{prop}{Propriété}    
\newtheorem{res}{Résultat}     
\usepackage{tkz-graph}
\usetikzlibrary{trees,decorations,decorations.pathmorphing,decorations.pathreplacing}                                      
\begin{document}

\begin{titlepage}
	\begin{center}
		\vspace{5.5cm}
		\huge{Rapport du Projet d'image}
		\vspace{2cm}
		
		\Huge{\TextSoulign{red}{}{Reconnaissance et indexation}}

		\Huge{\TextSoulign{red}{}{de forme}}
		\vspace{8cm}
		
		\LARGE{Patrice Coudert et Frédéric Lang}
		\vspace{3.5cm}
		
	\end{center}
	
	
	
\end{titlepage}

\tableofcontents

\chapter*{Introduction et structure du rapport}

Le principe du projet est de créer une signature. Pour cela nous avons créé un certains nombre d'indicateurs
que nous allons tout d'abord vous présenter. On en profitera pour s'intéresser à leur robustesse vis à vis de l'occlusion, du bruit, ...
Ces propriétés seront étudiés à la fois théoriquement et en pratique.

Pour les résultats pratiques, les scripts bash et les graphiques sont présent dans le dossier pour reproduire ces tests. Même si les graphiques
ne seront pas tous dans la rapport, il sont présent dans le dossier résultat. Les scripts bash servent à reproduire les test que nous 
avons effectués.

La suite expliquera comment nous utilisons ces indicateurs pour répondre aux questions. Nous proposons deux options: la première renverra la classe
la plus probable et la deuxième renverra les k images les plus proches.

\section*{Explications du programme}

Nous allons commencer expliquer comment utiliser notre programme. Le programme s'appelle $main$. Il prend deux options. La première est
le mode du programme. Les différents options sont:

\noindent$-help$: qui affiche les options et les explications de ce qu'elles font.

\noindent$-simil n$: qui renvoie les $n$ images les plus proches au sens de notre distance.

\noindent$-indn$: qui renvoie l'indicateur $n$ pour l'image en entrée.

\noindent$-disp$: qui crée un fichier $image.eps$ qui montre nos construction.(voir ci-après pour plus de  détails)

\noindent$-dispDT$: qui crée un fichier $image.eps$ qui montre les cercles où la distance au bord est constante.

Pour utiliser notre programme, il faut donc taper le nom du programme, puis le mode d'exécution souhaité, puis si voulue une des option d'affichage et enfin le nom du fichier. Voilà trois exemples:

\noindent $./main -ind1 -disp apple-1.pgm$

\noindent $./main -ind3 -dispDT apple-1.pgm$

\noindent $./main -simil 8 apple-1.pgm$
\chapter{Détails des indicateurs}
\section*{Introduction}
Les indicateurs que nous avons choisi essayent de faire ressortir les caractéristiques principales de l'image.
Après avoir regarder les images, on a décidé de grandeur caractéristiques simples et assez différentes selon les classes.
\'A partir de la sortie graphique du programme, la cohérence des indicateurs peut être vérifiée visuellement ce 
qui nous permet de vérifier facilement nos programmes. 
Les option $-disp$ et $-dispdt$ permet de réaliser ces vérifications visuels.

Nous avons fait le choix de nous intéresser qu'à la composante connexe principale c'est à dire de plus grande taille.
Les composantes connexes sont calculées en topologie 4.
On donne un exemple du changement d'image qu'impose notre choix sur $devie1-9.pgm$.
La composante principale est en noir et les composantes supprimés sont en jaune.
La raison de ce choix est double.
Premièrement on enlève des taches qui ne sont pas très caractéristiques de l'image. 
En effet ces taches peuvent résulter du bruit de notre image ou sont de taille minime et pas caractéristique de la classe.
Deuxièmement nos fonctions qui calcule le contour et l'enveloppe convexe ne sont pas résistant à ces problématiques.
On discute des améliorations possibles liés à ceci dans le section limitation et améliorations possibles.

%\includegraphics[scale=0.3]{device1-9-seulcc.pgm}

L'image ci-dessous est le résultat de notre algorithme pour l'image $guitar-1.pgm$.
Le contour de l'image est en rouge. Celui-ci est pris en topologie 4. 
Le contour de l'enveloppe convexe apparaît en bleu. Le barycentre apparaît en bleu et le point
où la distance au bord est maximal en vert.
Ces résultats sont obtenus en ajoutant l'option $-disp$ à n'importe quel image.
La deuxième image est obtenu sur la même image avec la commande $-dispDT$ est montre les cercle
où la distance au bord est constant.
\begin{center}
\includegraphics[scale=0.2]{guitar.jpg}
\end{center}

Nous allons présenter un par un les dix indicateurs que nous avons choisi.
Un script est présent pour calculer un indicateur sur toutes les images de la base de données.
Pour l'utiliser il suffit de le lancer avec le numéro de l'indicateur 
Pour chacun nous allons ensuite justifier théoriquement et en pratique de leur résistance/sensibilité au bruit, à un changement d'échelle et à une rotation. Toute ces sessions ne sont pas développé en détail. 
Mais, pour chaque indicateur, trois test ont été réalisé grâce aux scripts résistance et les courbe sont dans le dossier correspondant.
Pour refaire ces test, il suffit (après avoir compilé le programme) d'exécuter les script bash par la commande suivante:

\noindent $bash$ $resistance_bruit_1i.sh$  $apple$  $3$  $2$

Cette commande lance vingt test sur l'image $apple-3.pgm$ pour regarder l'influence du bruit pour l'indicateur $2$.
Ensuite pour tracer les courbes il suffit d'utiliser les script gnuplot dans le dossier $resultat/bruit/$.
Dans ce fichier, il suffit juste de changer le nom du fichier dont vous souhaiter la courbe.

\section{PERIMETRE} Cet indicateur mesure la longueur du contour de l'image. Il est destiné à différencier les formes très courbés ($lizzard$) de celle qui se rapproche plus d'un disque ($apple$). Il est calculé en extrayant le contour de la forme avec la fonction $contour$ implémentée dans le fichier $utils.cpp$. Cette fonction est celle qu'on a codé lors du TD5. Le contour obtenu correspond a une topologie 4. 
Pour ne pas le rendre sensible à un changement d'échelle, on divise par la racine de la taille de l'image. 
\subsection*{Resistance au bruit}
Le contour est par nature assez sensible au bruit. 
En effet, le bruit se situant majoritairement au bord, c'est le contour qui est le premier modifié.
Pour limiter ce problème, on ne garde que la plus grande composante connexe en topologie 4.
Ainsi, même si on s'attend à ce que la taille du contour augmente, le fait de supprimer les composantes connexes en topologie enlève un peu le bruit et donc la taille du contour reste acceptable.
Les test pratique confirme ce fait on voit un augmentation assez nette de notre indicateur.

%\includegraphics[scale=0.2]{bruit_contour.jpg}

\subsection*{Resistance à un changement d'échelle et à une rotation}
L'orientation de notre figure n'a que très peu d'impact sur notre contour. 
Lorsque la taille de l'image est assez grande, tourner l'image conserve la taille du contour même si à certain endroit particuliers, le contour varie un tout petit peu. les résultats pratiques confirme ce fait.
De même un changement d'échelle n'influe pas sur cet indicateur du fait de la division par la racine carré de la taille de l'image.

\section{DISQUECIRCONS} : Cet indicateur nous est venu à l'idée lorsque on a vu les classes hammer, lmfish, glass, ... et les classes fish, apple, ...
La longueur de l'image par rapport à sa taille est très différent.   A Partir de la position du barycentre et de la distance du point le plus éloigné de celui-ci, calculé par les fonctions \textbf{barycentre} et \textbf{distFarthestPoint} dans \textbf{utils.cpp}, on calcule le rapport entre la surface du disque circonscrit à la forme et la surface de de la forme.
\section{NBSEG} : Le nombre de segment qui délimitent l'enveloppe convexe de l'image. Les points qui relient ces segments sont calculé par l'algorithme de Graham implémenté par la fonction \textbf{convexHull} dans \textbf{convexhull.cpp}. Pour la première étape de l'algorithme où sont triés les points selon un ordre lié à un point \textbf{p0}, le tri n'a d'abord pas fonctionné car des points étaient alignés avec \textbf{p0}, mais ce problème a été corrigé en prenant en compte la distance avec celui-ci.
% todo : verifier algo
\section{MAXSEG} : Cet indicateur mesure la taille du plus grand segment délimitant l'enveloppe convexe.

 
\end{document}
